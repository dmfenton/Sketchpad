/**
 * Skia-based canvas renderer for React Native.
 *
 * Uses @shopify/react-native-skia for GPU-accelerated rendering
 * with support for blur, blend modes, and custom shaders.
 *
 * NOTE: Requires @shopify/react-native-skia to be installed:
 *   npm install @shopify/react-native-skia -w app
 */

import React, { useMemo } from 'react';
import { StyleSheet } from 'react-native';
import {
  Canvas,
  Path as SkiaPath,
  Group,
  Circle,
  Skia,
  BlurMask,
  Paint,
} from '@shopify/react-native-skia';

import type { Path, Point, RendererProps, StrokeStyle } from '@code-monet/shared';
import {
  getEffectiveStyle,
  getFreehandOutline,
  outlineToSvgPath,
  PAINTERLY_FREEHAND_OPTIONS,
  getBristleOutlines,
  getBrushPreset,
  brushPresetToFreehandOptions,
} from '@code-monet/shared';

/**
 * Convert points to Skia path for filled stroke.
 */
function pointsToSkiaPath(points: Point[]): ReturnType<typeof Skia.Path.MakeFromSVGString> {
  if (points.length === 0) return null;

  const outline = getFreehandOutline(points, PAINTERLY_FREEHAND_OPTIONS);
  const svgD = outlineToSvgPath(outline);
  return Skia.Path.MakeFromSVGString(svgD);
}

/**
 * Render a single stroke with painterly effects.
 */
function PainterlyStroke({
  points,
  style,
  brushName,
  blur = 0,
}: {
  points: Point[];
  style: StrokeStyle;
  brushName?: string;
  blur?: number;
}): React.ReactElement | null {
  const { path, bristlePaths } = useMemo(() => {
    if (points.length === 0) return { path: null, bristlePaths: [] };

    // Get brush preset if specified
    const brush = brushName ? getBrushPreset(brushName as any) : null;
    const options = brush
      ? brushPresetToFreehandOptions(brush, style.stroke_width)
      : { ...PAINTERLY_FREEHAND_OPTIONS, size: style.stroke_width * 2 };

    // Main stroke outline
    const outline = getFreehandOutline(points, options);
    const mainPath = outline.length > 0 ? Skia.Path.MakeFromSVGString(outlineToSvgPath(outline)) : null;

    // Bristle strokes for texture
    let bristles: ReturnType<typeof Skia.Path.MakeFromSVGString>[] = [];
    if (brush && brush.bristleCount > 0) {
      const bristleOutlines = getBristleOutlines(
        points,
        brush.bristleCount,
        brush.bristleSpread * style.stroke_width,
        options
      );
      bristles = bristleOutlines
        .map((outline) => (outline.length > 0 ? Skia.Path.MakeFromSVGString(outlineToSvgPath(outline)) : null))
        .filter((p): p is NonNullable<typeof p> => p !== null);
    }

    return { path: mainPath, bristlePaths: bristles };
  }, [points, style.stroke_width, brushName]);

  if (!path) return null;

  const brush = brushName ? getBrushPreset(brushName as any) : null;

  return (
    <Group>
      {/* Bristle strokes (if any) */}
      {bristlePaths.map((bristlePath, i) => (
        <SkiaPath
          key={`bristle-${i}`}
          path={bristlePath}
          color={style.color}
          style="fill"
          opacity={(brush?.bristleOpacity ?? 0.3) * style.opacity}
        />
      ))}

      {/* Main stroke with optional blur */}
      {blur > 0 ? (
        <Group>
          <BlurMask blur={blur} style="normal" />
          <SkiaPath
            path={path}
            color={style.color}
            style="fill"
            opacity={(brush?.mainOpacity ?? 1) * style.opacity}
          />
        </Group>
      ) : (
        <SkiaPath
          path={path}
          color={style.color}
          style="fill"
          opacity={(brush?.mainOpacity ?? 1) * style.opacity}
        />
      )}
    </Group>
  );
}

/**
 * Render a single-point stroke as a dot.
 */
function StrokeDot({ point, style }: { point: Point; style: StrokeStyle }): React.ReactElement {
  const radius = Math.max(style.stroke_width / 2, 1.5);
  return <Circle cx={point.x} cy={point.y} r={radius} color={style.color} opacity={style.opacity} />;
}

/**
 * Pen position indicator.
 */
function PenIndicator({
  position,
  penDown,
  color,
}: {
  position: Point;
  penDown: boolean;
  color: string;
}): React.ReactElement {
  const outerRadius = penDown ? 6 : 8;
  const innerRadius = penDown ? 3 : 4;

  return (
    <Group>
      {/* Outer ring */}
      <Circle
        cx={position.x}
        cy={position.y}
        r={outerRadius}
        color={color}
        style="stroke"
        strokeWidth={1.5}
        opacity={0.6}
      />
      {/* Inner dot */}
      <Circle cx={position.x} cy={position.y} r={innerRadius} color={color} opacity={0.8} />
    </Group>
  );
}

/**
 * Skia-based renderer with GPU acceleration and painterly effects.
 */
export function SkiaRenderer({
  strokes,
  currentStroke,
  agentStroke,
  agentStrokeStyle,
  penPosition,
  penDown,
  styleConfig,
  showIdleAnimation,
  width,
  height,
  primaryColor,
}: RendererProps): React.ReactElement {
  const isPaintMode = styleConfig.type === 'paint';

  return (
    <Canvas style={styles.canvas}>
      {/* Completed strokes */}
      {strokes.map((stroke, index) => {
        const style = getEffectiveStyle(stroke, styleConfig);
        const points = stroke.points;

        // Single point = dot
        if (points.length === 1) {
          return <StrokeDot key={index} point={points[0]!} style={style} />;
        }

        return (
          <PainterlyStroke
            key={index}
            points={points}
            style={style}
            brushName={isPaintMode ? stroke.brush : undefined}
            blur={isPaintMode ? 1.5 : 0}
          />
        );
      })}

      {/* Current human stroke */}
      {currentStroke.length > 0 && (
        <PainterlyStroke
          points={currentStroke}
          style={styleConfig.human_stroke}
          blur={isPaintMode ? 1 : 0}
        />
      )}

      {/* Agent in-progress stroke with extra blur for soft effect */}
      {agentStroke.length > 0 && (
        <PainterlyStroke
          points={agentStroke}
          style={{
            ...styleConfig.agent_stroke,
            ...agentStrokeStyle,
          }}
          blur={isPaintMode ? 2 : 0}
        />
      )}

      {/* Pen position indicator */}
      {penPosition && (
        <PenIndicator position={penPosition} penDown={penDown} color={primaryColor} />
      )}

      {/* TODO: Idle animation (particles) - needs Skia-specific implementation */}
    </Canvas>
  );
}

const styles = StyleSheet.create({
  canvas: {
    flex: 1,
  },
});
